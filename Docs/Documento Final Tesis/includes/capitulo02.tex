%Empieza configuracion de capitulo
\setstretch{1.0}
\titleformat{\chapter}[block]{\Large\bfseries}{CAP'ITULO \Huge\thechapter\vspace{25 pt}}{0 pt}{\\\fontsize{26}{36}\selectfont}
\titlespacing{\chapter}{0 pt}{30 pt}{50 pt}[0 pt]
\titleformat{\section}{\Large\bfseries}{\thesection}{0 pt}{\hspace{30 pt}}
\titleformat{\subsection}{\large\bfseries}{\thesubsection}{0 pt}{\hspace{30 pt}}
\pagestyle{fancy}
\fancyhead[LO,LE]{\footnotesize\textit{\leftmark}}
\fancyhead[RO,RE]{\thepage}
\fancyfoot[CO,CE]{}
%Termina configuracion de capitulo

\chapter{Marco Te'orico}
\setstretch{1.5} %Regresa el interlineado a 1.5

\normalsize

\section{Nociones B'asicas de Calidad de Software}
\noindent
En esta secci'on se dar'an las nociones b'asicas que se deben de conocer en el tema de la Calidad de Software antes de poder hablar de temas m'as espec'ificos.

\subsection{Definici'on de Calidad de Software}
\noindent
El concepto de Calidad de Software ha sido definido de varias formas por distintos autores. A continuaci'on presento algunas de las definiciones m'as destacables:

\begin{itemize}
	\item ``Calidad significa cumplir con los requerimientos'' - \cite{Crosby1979};
	\item ``Calidad consiste en las caracter'isticas de los productos que cubren las necesidades de los clientes produciendo satisfacci'on gracias al producto'' - \cite{Juran1988};
	\item ``Calidad consiste en la libertad de deficiencias'' - \cite{Juran1988};
	\item ``Calidad de Software es: El grado en que un sistema, componente o proceso cumple con los requerimientos especificados'' - IEEE 1991;
	\item ``Calidad de Software es: El grado en que un sistema, componente o proceso cumple con las necesidades o expectativas del usuario'' - IEEE 1991;
	\item ``Como la belleza, todos tienen su idea de que es la calidad'' - \cite{Davies2000}.
\end{itemize}

Tomando en cuenta estas definiciones, hay autores que se inclinan por definir Calidad de Software en relaci'on al cumplimiento de requerimientos, y otros que prefieren relacionar la calidad con la satisfacci'on final del cliente. Finalmente las empresas deben de buscar un balance apropiado entre ambos enfoques para lograr el 'exito en su labor.

\subsection{Atributos de Calidad}
\noindent
Los atributos de calidad son caracter'isticas no funcionales de un sistema. Tambi'en se conocen como requerimientos no funcionales y son factores que determinan la calidad interna y externa de un producto.

Los principales atributos de calidad son\cite{RohitDhiman2005}:

\begin{itemize}
	\item \emph{Funcionalidad}. Este atributo se refiere a que el sistema cubra adecuadamente las necesidades funcionales del cliente. Sus caracter'isticas espec'ificas son: Precisi'on, interoperabilidad, y seguridad;
	\item \emph{Confiabilidad}. Este atributo se refiere a que tan confiable es el sistema, a si el sistema va a responder efectivamente cuando es necesario. Sus caracter'isticas espec'ificas son: Madurez, tolerancia a fallas y la habilidad de recuperarse a 'estas;
	\item \emph{Usabilidad}. Este atributo se refiere a que tan f'acil, intuitivo y usable es el sistema para el usuario. Sus caracter'isticas espec'ificas son: La facilidad con la que el sistema es entendido, que tan f'acil se aprende a usarlo, operatividad y atractividad;
	\item \emph{Eficiencia}. Este atributo se refiere al desempe'no del sistema. Sus caracter'isticas espec'ificas son: Desempe'no en el tiempo y utilizaci'on de recursos;
	\item \emph{Mantenibilidad}. Este atributo se refiere a como el sistema puede ser mantenido y mejorado en el tiempo. Sus caracter'isticas espec'ificas son: Analizabilidad, modificabilidad, estabilidad y facilidad para ser probado;
	\item \emph{Portabilidad}. Este atributo se refiere a como el sistema puede ser instalado en distintos ambientes. Sus caracter'isticas espec'ificas son: Adaptabilidad, facilidad para ser instalado, coexistencia y reemplazabilidad.
\end{itemize}

\section{Enfoques de la Calidad de Software}
\noindent
Existen tres principales enfoques bajo los cuales la industria busca mejorar la calidad en el desarrollo de software. Estos son: Adherencia a procesos, elaboraci'on de pruebas y revisiones de producto.

\subsection{Adherencia a Procesos}
\noindent
Un enfoque que se tiene para dar calidad a los sistemas de software se hace mediante la definici'on y adherencia a procesos. La idea de este enfoque es que las organizaciones tengan procesos bien definidos, y los sigan religiosamente. Esto con el objetivo de siempre poder obtener resultados similares en sus diferentes procesos.

Dos grandes ejemplos de este enfoque son el ISO9000 y CMMI.

ISO9000 es una familia de est'andares relacionados a la administraci'on de la calidad de los sistemas, y est'an dise'nados para ayudar a las organizaciones a asegurarse que cumplen con las necesidades de los clientes y las dem'as partes interesadas. Los est'andares que componen al ISO900 son \cite{Herzwurm1996}:

\begin{itemize}
	\item \emph{ISO9000}. Es la introducci'on al ISO 9000, se refiere a la selecci'on y uso de los ISO9001-9004;
	\item \emph{ISO9001}. Modelo para asegurar la calidad en el dise'no, desarrollo, producci'on e instalaci'on en las organizaciones;
	\item \emph{ISO9002}. Modelo para asegurar la calidad en la producci'on, instalaci'on y servicio. Est'a basado en el ISO9001 pero tambi'en incluye la parte de creaci'on de nuevos productos;
	\item \emph{ISO9003}. Modelo para asegurar la calidad en las inspecciones finales y el proceso de pruebas;
	\item \emph{ISO9004}. Modelo para asegurar la calidad a trav'es de situaciones preventivas.
\end{itemize}

CMMI (siglas en ingl'es de Capability Maturity Model Integration) es un enfoque de mejora de procesos que tiene como meta ayudar a las empresas a mejorar su desempe'no. Este modelo contiene los elementos esenciales de los procesos efectivos, y describe un proceso evolutivo  de mejora tanto para mejorar procesos inmaduros como para mejorar procesos maduros. Cuenta con 5 niveles de madurez que son los siguientes\cite{Yoo2005}:

\begin{itemize}
	\item \emph{Nivel 1 (Inicial)}. Procesos impredecibles, poco controlados y que reaccionan a las situaciones;
  \item \emph{Nivel 2 (Administrado)}. Proceso caracterizado por estar organizado en proyectos, normalmente es reactivo a las situaciones;
	\item \emph{Nivel 3 (Definido)}. La organizaci'on tiene procesos definidos y es proactiva. Los proyectos se rigen mediante los procesos de la organizaci'on;
	\item \emph{Nivel 4 (Administrado Cuantitativamente)}. Los procesos de la organizaci'on son controlados y medidos;
	\item \emph{Nivel 5 (Optimizaci'on)}. Se enfoca en la mejora de procesos.
\end{itemize}

\subsection{Pruebas de Software}
\noindent
Un segundo enfoque es aquel que est'a basado en la realizaci'on de pruebas para asegurar la calidad del sistema.

Las pruebas de software son un proceso de verificaci'on y validaci'on de un sistema de software. Estas actividades se realizan con el objetivo de encontrar defectos en un sistema de software. Con esta definici'on surgen tres conceptos \cite{JohnE.Bentley}:

\begin{itemize}
	\item \emph{Verificaci'on}. Es asegurarse que el sistema hace lo que el usuario final necesita que haga.
	\item \emph{Validaci'on}. Es asegurarse que las operaciones que realice el sistema sean correctas.
	\item \emph{Defecto}. Es una diferencia entre el resultado esperado y el resultado obtenido.
\end{itemize}

Las pruebas de software son realizadas para encontrar los defectos en el sistema de software antes de que estos lleguen al usuario final.

Existen distintos tipos de pruebas de software, los m'as comunes son \cite{JohnE.Bentley}:

\begin{itemize}
	\item \emph{Pruebas Unitarias}. Son pruebas ejecutadas a una unidad de sistema. Dependiendo del tipo de proyecto, una unidad puede ser considerada, un m'etodo dentro de alguna clase, un archivo de c'odigo fuente completo entre otras. En estas pruebas solo se asegura la funcionalidad independiente de la unidad.
	\item \emph{Pruebas de Sistema}. Es ejecutar todas las pruebas unitarias en un escenario real. Se refieren a utilizar el sistema bajo condiciones normales donde las unidades interact'uen entre s'i.
	\item \emph{Pruebas de Estr'es}. Es ejecutar pruebas de sistema pero bajo condiciones de estr'es, con una carga de trabajo muy alta y fuera de lo normal.
	\item \emph{Pruebas de Aceptaci'on de Usuari}o. Tambi'en conocidas como pruebas Beta, tratan de darle una versi'on funcional, aunque no propiamente final,  del sistema al usuario final, para que estos se aseguren de que el sistema hace lo que ellos necesitan y lo haga de forma correcta.
	\item \emph{Pruebas de Regresi'on}. Estas pruebas se ejecutan cuando se realiza la correcci'on de alg'un defecto. Todos los componentes o unidades que son afectados por este cambio tienen que ser probados de nuevo para asegurarse de que la correcci'on del defecto original no introdujo nuevos defectos.
\end{itemize}

Sin embargo el enfoque de este Trabajo de Tesis es justamente evitar hacer pruebas extensivas. Como se mencion'o en la secci'on 1.1 del presente Trabajo de Tesis, gran parte de la problem'atica actual se debe a que los productos del proceso de desarrollo de software llegan con una calidad tan baja a la etapa de pruebas, que a las organizaciones de desarrollo normalmente les toma la mitad del tiempo total del proyecto terminar esta etapa. El Trabajo de Tesis se enfoca en la revisi'on y prevenci'on, con el 'ultimo objetivo de que los productos del proceso de desarrollo de software lleguen libres de defectos a la etapa de pruebas.

\subsection{Revisiones de Productos de Trabajo}
\noindent
Este es el enfoque del Trabajo de Tesis. Las revisiones de los productos de trabajo son evaluaciones y revisiones de estos productos por parte de uno o m'as compa'neros del equipo de desarrollo calificados para hacerlo.

La idea principal detr'as de las revisiones es detectar los defectos lo antes posible en el proceso de desarrollo de software. Esto evita que los errores permanezcan durante el proceso de desarrollo, donde se va haciendo m'as dif'icil encontrarlos y corregirlos mientras avanza el proyecto.

Los tipos de revisiones de productos m'as comunes son: Revisiones personales, revisiones entre colegas, caminatas e inspecciones.

En la subsecci'on 3.4 del presente Trabajo de Tesis se esbozar'an distintas estrategias para promover la cultura de la revisi'on y la prevenci'on, y en la subsecci'on 3.4.2 se ahondar'a en el tema de las t'ecnicas de detecci'on de defectos.

\section{Importancia de la Calidad en el Desarrollo de Software}
\noindent
El software es una tecnolog'ia sorprendente. Es un producto totalmente intelectual por lo que no tiene costos de producci'on, aparte puede ser distribuido mundialmente en segundos, no se deteriora con el tiempo y es la forma m'as econ'omica y sencilla de implementar casi cualquier funci'on compleja.

En todos los campos de la ingenier'ia y la ciencia, m'as de la mitad del tiempo de cualquier profesional lo utiliza desarrollando, mejorando, manteniendo o usando un sistema de software. Es sin duda uno de los negocios m'as grandes e importantes de la actualidad\cite{Humphrey2002}.

Tomando en cuenta lo anterior, muchos ejecutivos de varias organizaciones vieron las oportunidades de negocio en el software, sin embargo implementar un departamento de software efectivo no es una tarea trivial, y la calidad en los productos que se desarrollen es clave para el 'exito.

\subsection{El software en las organizaciones}
\noindent
Para administrar una organizaci'on o un departamento dentro de una organizaci'on dedicado al software se necesita tener en cuenta los siguientes principios de administraci'on:

\begin{enumerate}
	\item Reconocer la importancia del software en el negocio;
	\item La calidad en los productos de software debe de ser la principal prioridad. La calidad es una elecci'on con consecuencias econ'omicas, si no se paga por la calidad al principio del desarrollo, se pagar'a una cantidad mucho m'as alta despu'es. Para realmente lograr que los proyectos cumplan con los calendarios y los costos, el trabajo tiene que realizarse de forma correcta desde el principio;
	\item El software de calidad se desarrolla por personas disciplinadas y motivadas. Si los profesionales del software no est'an convencidos y entrenados en m'etodos de calidad, no van a seguir las pr'acticas requeridas y no producir'an software de calidad.
\end{enumerate}

\subsection{?`Por qu'e los proyectos de software fallan?}
\noindent
La raz'on principal por la que los proyectos fallan es administraci'on inadecuada. Una buena administraci'on requiere dos cosas: Estar enfocados en la calidad, e ingenieros motivados que realicen un trabajo disciplinado.

Las causas m'as comunes por las cuales los proyectos fallan son\cite{Humphrey2002}:

\begin{itemize}
	\item \emph{Calendarios poco realistas}. Cuando un proyecto de software inicia con calendarios poco realistas, el proyecto ser'a entrado despu'es de lo que se hubiera hecho con un calendario realista. Esto es porque los ingenieros comienzan a hacer trabajo r'apido y de poca calidad para alcanzar el calendario. El resultado de esto son productos de baja calidad, los cuales est'an llenos de defectos, lo que se traduce a una extensa etapa de pruebas;
	\item \emph{Equipo inadecuado}. La 'unica forma de terminar un proyecto de software de manera r'apida y efectiva es asignar el n'umero adecuado de personas y protegerlas de interrupciones y distracciones;
	\item \emph{Cambio de requerimientos}. Es normal que los requerimientos cambien en las fases iniciales del proyecto, sin embargo llega un punto que esta situaci'on es muy perjudicial. Se tiene que identificar este punto para evitar p'erdidas de dinero y cambios que afecten en sobremanera el trabajo que se est'a haciendo;
	\item \emph{Baja calidad en el trabajo realizado}. Si el trabajo que se realiza es de baja calidad, va a ocasionar que la fase de pruebas sea muy larga y se gaste mucho tiempo arreglando defectos durante el proceso de desarrollo;
	\item \emph{Creer en la magia}. No existe la bala de plata. Muchas veces se cree que con una nueva tecnolog'ia o forma de desarrollo se resolver'an todos los problemas, y lo que ocurre generalmente es que nos pueden llevar a serios problemas.
\end{itemize}

El costo de una baja calidad de software es dif'icil de ver hasta el final del proyecto. Com'unmente, la baja calidad le dar'a problemas a'un a los usuarios finales ya que el proyecto se haya terminado. Los errores m'as comunes son: l'ideres de proyecto que toman compromisos irresponsables y no insisten en que el trabajo se haga de forma correcta. Todos los problemas mencionados anteriormente se pudieron evitar si la administraci'on hubiera insistido en planear correctamente el trabajo y realizarlo de forma disciplinada.

\subsection{La Calidad es Negocio}
\noindent
Hay tres razones fundamentales para insistir en que la Calidad de Software tiene que ser medida y administrada\cite{Humphrey2002}:

\begin{enumerate}
	\item La baja calidad en el software puede causar da'nos severos a la propiedad, y en algunos casos puede matar personas;
	\item El trabajo de calidad ahorra tiempo y dinero;
	\item Si la gerencia y el l'ider de proyecto no insisten en la administraci'on de la calidad de software, nadie m'as lo har'a.
\end{enumerate}

Varios estudios han demostrado que incluso los ingenieros experimentados inyectan un defecto cada diez l'ineas de todo\cite{Humphrey2002}. Esto no significa que los programadores sean incompetentes, simplemente son humanos.

El costo de encontrar y corregir los defectos se incrementa en cada fase del proceso de desarrollo de software. Entre m'as permanezca un defecto en el sistema, ser'a m'as dif'icil removerlo.

Existen varias t'ecnicas para remover defectos antes de llegar a la fase de pruebas. Varias de estas t'ecnicas fueron mencionadas en la secci'on 3.2.3 del presente Trabajo de Tesis, y ser'an descritas a mayor profundidad en la secci'on 3.4.2. Una de estas t'ecnicas por ejemplo, es la revisi'on de c'odigo, en las que se lee y revisa el c'odigo producido en busca de defectos. Estas actividades suelen tomar una peque'na cantidad de tiempo, y cada defecto encontrado ahorra una gran cantidad de tiempo en la fase de pruebas.

A diferencia de las revisiones de c'odigo, la fase de pruebas es una actividad de calidad mucho m'as larga. La raz'on de esto es que en las pruebas de software solo se revela los s'intomas del defecto, mientras que en las revisiones se encuentra directamente el defecto.

La mejor manera de remover defectos de software es realizando revisiones de c'odigo, ya que estas son m'as baratas y m'as efectivas que las pruebas de software. El ingeniero que desarroll'o el programa es el m'as indicado para encontrar y corregir sus propios defectos.

Aun conociendo la efectividad de las revisiones de c'odigo, muchas organizaciones no las utilizan. La raz'on es que para realizar revisiones de c'odigo efectivas se requieren m'etodos disciplinados.

Si los proyectos tienen la mayor parte de su tiempo dedicado a la fase de pruebas de software, va a ser casi imposible planearlo y darle seguimiento. Si se desea que los planes tengan compromisos precisos y realizables, se debe de insistir en realizar un trabajo de calidad.

\section{Organizaciones con Procesos de Calidad}
\noindent
Existen varios factores que se tienen que tomar en cuenta en una organizaci'on que se dedique al desarrollo de software para que esta produzca sistemas de alta calidad.

\subsection{3.4.1	Administraci'on Racional}
\noindent
El principio de la administraci'on racional es confiar que los miembros de un equipo de desarrollo de software son profesionales preocupados en el 'exito del proyecto.

En la administraci'on racional se necesita crear planes, seguir estos planes, y corregir los problemas antes de que se salgan de control. Sus cuatro elementos principales son\cite{Humphrey2002}:

\begin{enumerate}
	\item Establecer metas agresivas a largo plazo, pero descomponerlas en metas real'isticas y medibles a corto plazo;
	\item Insistir en la creaci'on de planes e insistir que estos planes sean creados por las personas que har'an el trabajo. Los planes tienen que ser detallados y completos, y tienen que ser revisados a conciencia en busca de omisiones y otros errores;
	\item Se tienen que utilizar datos e informaci'on. Si se utiliza de forma objetiva los datos y la informaci'on del desempe'no del equipo, se demuestra la confianza que se tiene en el equipo y la disposici'on que existe para escuchar sus problemas, planes e ideas;
	\item Dar seguimiento al trabajo realizado y  utilizar la informaci'on actual para anticipar y resolver problemas futuros. Los calendarios y planes se salen de control d'ia a d'ia.
\end{enumerate}

Cuando el trabajo es planeado, medido y monitoreado, se puede analizar el desempe'no del proyecto y del negocio.

\subsection{Transformado las Organizaciones}
\noindent
Las organizaciones siempre quieren realizar sus actividades m'as r'apido, de mejor manera y a menor costo. Un principio b'asico en la administraci'on es: Lo que se mide puede ser administrado, y lo que es administrador puede realizarse. Al contrario, lo que no es medido com'unmente se ignora.

Las tres principales cosas en las que una organizaci'on se debe de concentrar para hacer el cambio de calidad son: Calendario, calidad y costo. Para lograr esto se tiene que cambiar la forma en que los ingenieros trabajan. Para acelerar el trabajo, te debes de enfocar a las actividades, como se hacen y que se necesita para acelerar el proyecto.

El primer requerimiento para ser m'as r'apido, mejor y m'as econ'omico es hacer planes detallados y comprensivos. Los ingenieros son quienes deben de realizar estos planes. Despu'es la gerencia debe de asegurarse que los ingenieros tengan las habilidades y conocimientos necesarios para elaborar estos planes. Finalmente los jefes directos de los ingenieros, com'unmente los l'ideres de proyecto, deben de participar en la elaboraci'on de los planes, y finalmente, la administraci'on y la gerencia debe de revisar que estos planes sean completos.

El siguiente requerimiento es que los ingenieros deben de utilizar los planes que elaboraron para realizar el trabajo. Uno de los mayores beneficios de tener planes detallados es que los equipos pueden balancear las cargas de trabajo. La calidad es clave aqu'i, se necesita que todos los productos de trabajo tengan alta calidad, si no, eventualmente tendr'an que ser corregidos y tendr'an un costo extra.

Una meta de calidad en la organizaci'on deber'ia ser que los ingenieros est'en entrenados en las pr'acticas de calidad y que utilicen estas pr'acticas para realizar el trabajo.

La estrategia principal para reducir el costo de ingenier'ia es ayudar a los ingenieros a maximizar el tiempo trabajado en actividades que se encuentren dentro del plan de desarrollo. En el tiempo de actividades de desarrollo no se toma en cuenta el tiempo invertido en juntas, descansos, asesor'ia por parte de la gerencia u otras actividades requeridas dentro de los proyectos de ingenier'ia. En promedio los ingenieros invierten a las actividades planeadas entre diez y quince horas por semana.

Para maximizar el tiempo que se invierte en actividades planeadas existen cuatro elementos clave: Medir el tiempo invertido en las actividades planeadas, mantener a los ingenieros motivados, planear el tiempo a invertir en las actividades planeadas, y revisi'on y apoyo por parte de la administraci'on. 

Entonces para que una organizaci'on pueda mejorar su calidad las diferentes partes deben de cumplir con lo propuesto anteriormente. Los ingenieros deben de utilizar las pr'acticas de calidad, as'i como planear y dar seguimiento al trabajo realizado y finalmente medir y administrar la calidad del producto. Los l'ideres o administradores de proyecto deben iniciar y mantener este nuevo comportamiento, as'i como monitorear los planes y balancear efectivamente la carga de trabajo. La gerencia o l'ideres de la organizaci'on deben de proveer un ambiente disciplinado y atractivo de trabajo, establecer las metas a largo plazo y dar seguimiento al trabajo realizado.

\subsection{Cambiando el Comportamiento de los Ingenieros}
\noindent
La calidad del producto de software desarrollado est'a determinada por el proceso que se utiliz'o para crear el producto. La 'unica forma de crear productos de software de calidad es implementar t'ecnicas de calidad de software bajo un proceso disciplinado.

Para que los ingenieros sean capaces de crear planes detallados basados en informaci'on hist'orica, y sigan estos planes para hacer el trabajo, los ingenieros deben estar capacitados y convencidos que el realizar estas acciones va a fomentar el 'exito en el proyecto.

La idea b'asica detr'as de esto es que si las partes peque'nas del sistema no tienen alta calidad, el sistema completo tampoco ser'a de calidad. Es por esto que los ingenieros deben de enfocarse en la calidad desde el principio del ciclo de desarrollo, teniendo cada componente por m'inimo que sea, una calidad envidiable.

Todas las partes a cargo del desarrollo del proyecto son responsables de implementar los distintos m'etodos calidad. La gerencia y los l'ideres de proyecto son los responsables de implementar estos m'etodos de calidad y los ingenieros deben de seguir fielmente estos m'etodos. Toma el mismo tiempo escribir programas de alta calidad que lo que toma escribir programas plagados de defectos.

\subsection{Construyendo Equipos Motivados}
\noindent
Los mejores resultados dentro de una organizaci'on se obtienen cuando la administraci'on conf'ia en sus ingenieros. En el contexto de negocios hay tres formas de motivar a las personas: Miedo, avaricia y compromiso. Solo en los trabajos m'as simples el miedo y la avaricia son motivadores efectivos.

Para crear equipos motivamos, se necesita que todos los ingenieros est'en capacitados para realizar el trabajo que van a hacer. Despu'es se tiene que convencer a los ingenieros de que el trabajo que van a realizar es importante y que se necesita su compromiso personal para que tenga 'exito. Se tienen que plantear metas agresivas, pero crear planes detallados para alcanzarlas, si los planes creados por los ingenieros no cumplen la gerencia se tiene que pedir a los ingenieros que justifiquen sus planes. Los planes tienen que ser revisados en busca de partes donde se pueda recortar tiempo, pero tambi'en deben de buscarse omisiones. Lo que se necesita es un compromiso realista que el equipo pueda cumplir, no una vana promesa.

El l'ider de proyecto debe de checar el progreso en el trabajo cada semana, y la gerencia al menos cada mes.

\subsection{Beneficios del Trabajo de Calidad}
\noindent
Cuando se utilizan correctamente m'etodos disciplinados para planear, dar seguimiento y administrar el trabajo, los productos elaborados ser'an de alta calidad y dentro de calendario. M'as importante a'un, tendremos una noci'on bastante precisa de en qu'e parte del proceso de desarrollo se encuentra el proyecto, y una predicci'on fiable de cu'ando se va a terminar.

El tiempo que se requiere para escribir programas de alta calidad es el mismo que se necesita para escribir programas de baja calidad. Los productos de calidad reducen el tiempo desarrollo. Entre menos defectos existan, el costo ser'a menor y los estimados ser'an m'as efectivos. Tambi'en el tiempo que se requiera para terminar la etapa de pruebas ser'a mucho menor.

\subsection{Pasos para Mejorar la Calidad}
\noindent
Esta subsecci'on presenta un resumen r'apido de la secci'on 3.4, dando los puntos principales para que una organizaci'on haga una transformaci'on hacia la cultura de la alta calidad\cite{Humphrey2002}:

\begin{enumerate}
	\item Establecer una pol'itica de calidad. Se debe de tener claro que el trabajo de calidad es la primera prioridad. Las pol'iticas de calidad deben de ser escritas y publicadas, haciendo 'enfasis en que hacer las cosas de forma correcta es la mejor forma de hacerlas;
	\item La gerencia debe de tener en cuenta que son los responsables de la mejora de los procesos. Normalmente se opta por asignar una persona en particular para dar seguimiento a la mejora que se va teniendo;
	\item Establecer metas precisas y medibles. Para alcanzar metas agresivas, las metas deben de ser claras y tener formas de medirlas para hacer comparaciones;
	\item Los l'ideres de proyecto deben de ser responsables de la mejora de cada uno de los equipos a su cargo;
	\item Se deben de proveer los recursos necesarios para realizar las mejoras;
	\item Se deben de identificar las 'areas de mejora, priorizarlas y enfocarse en las m'as importantes. Ya que se hayan mejorado las 'areas de mayor prioridad se puede pasar a mejorar otras;
	\item Se debe de dar seguimiento al proceso de mejora.
\end{enumerate}

\section{El Proceso Personal del Software}
\noindent
Los m'etodos tradicionales para asegurar la calidad del software en desarrollo son: Inspecci'on de requerimientos, inspecci'on de dise'no, compilaci'on, inspecci'on de c'odigo y pruebas. La tabla \ref{DefectosNivelCMM} muestra los niveles de defectos promedio por las organizaciones seg'un su nivel de CMM\cite{Humphrey}.

\begin{table}
	\centering
		\begin{tabular}{| c | c |}
			\hline
			\textbf{Nivel de CMM} & \textbf{Defectos/Mil de L'ineas de C'odigo} \\ \hline
			1 & 7.5 \\ \hline
			2 & 6.24 \\ \hline
			3 & 4.73 \\ \hline
			4 & 2.228 \\ \hline
			5 & 8 \\ 
			\hline
		\end{tabular}
	\caption{N'umero de Defectos por Nivel de CMM}
	\label{DefectosNivelCMM}
\end{table}

Para mejorar la calidad de productos de software, aparte de utilizar los m'etodos tradicionales de calidad, se debe de medir y dar seguimiento al trabajo personal. Si el objetivo es tener un sistema de software de alta calidad, cada parte del sistema debe de ser de alta calidad. La estrategia de PSP (por sus siglas en ingl'es Personal Software Process) es administrar los defectos contenidos en todas las partes del sistema. Con partes de alta calidad, el proceso de desarrollo de software se puede escalar sin perder productividad.

\subsection{?`Qu'e es la calidad de software?}
\noindent
La definici'on de calidad deber'ia de basarse en las necesidades de los usuarios\cite{Humphrey}.

Los usuarios deben de contar con un producto funcional. Si el producto tiene muchos defectos este no se desempe'nar'a con una consistencia razonable. Sin embargo esto no significa que los defectos son siempre la principal prioridad. Despu'es de los defectos encontramos caracter'isticas de calidad como: Desempe'no, seguridad, usabilidad, compatibilidad, funcionalidad, confiabilidad entre otras.

Normalmente se gasta un tiempo excesivo en la correcci'on de defectos, dejando muy poco tiempo dedicado a las otras caracter'isticas mencionadas anteriormente.

Aunque nos referimos que los defectos son solo una parte de la calidad del producto de software, son el principal objetivo del PSP, ya que la administraci'on efectiva de estos es esencial para la administraci'on de costo, calendario y los dem'as aspectos de la calidad de producto.

\subsection{La Econom'ia de la Calidad de Software}
\noindent
La calidad de software es un problema de calidad. Cada prueba realizada cuesta dinero y toma tiempo.

Entre m'as tiempo el defecto permanezca en el producto, el impacto es m'as alto. Por ejemplo encontrar un problema de requerimientos cuando el cliente ya est'a utilizando el producto puede ser demasiado costoso, en cambio encontrar el defecto durante una revisi'on de c'odigo ser'a mucho menos costoso. El objetivo entonces es, remover los defectos lo antes posible en el proceso de desarrollo. Esto se logra haciendo revisiones e inspecciones de cada producto de trabajo lo m'as pronto posible de que se haya terminado el producto.

El proceso de pruebas puede ser muy efectivo para identificar problemas de desempe'no, usabilidad y problemas operacionales, pero no es tan efectivo removiendo grandes cantidades de defectos. Los datos de estudios realizados demuestran que mientras m'as tarde en el proceso de desarrollo sea encontrado un defecto, es m'as dif'icil encontrarlo y removerlo.

\subsection{Tipos de Defectos}
\noindent
Los tipos de defectos m'as comunes son: Errores en requerimientos, errores de dise'no, errores de codificaci'on, errores de documentaci'on, correcciones defectuosas. La tabla \ref{TiposDefectosKLOC} presenta el n'umero de defectos cada mil l'ineas de c'odigo seg'un el tipo de defecto\cite{Humphrey}.

\begin{table}
	\centering
		\begin{tabular}{| c | c |}
			\hline
			\textbf{Tipos de Defecto} & \textbf{Defectos/Mil de L'ineas de C'odigo} \\ \hline
			Requerimientos & 2.3 \\ \hline
			Dise'no & 1.9 \\ \hline
			Codificaci'on & 0.9 \\ \hline
			Documentación & 1.2 \\ \hline
			Correcciones Defectuosas & 1.2 \\ \hline
			Total & 7.5 \\
			\hline
		\end{tabular}
	\caption{Tipos de Defectos por Mil L'ineas de C'odigo}
	\label{TiposDefectosKLOC}
\end{table}

\subsection{M'etricas de Calidad}
\noindent
Para mejorar la calidad, se debe de medir la calidad\cite{Humphrey}. El PSP propone el uso de las siguientes m'etricas para medir la calidad de las organizaciones de software: El Yield de Calidad, el Costo de la Calidad (COQ), la Tasa de Revisiones, la Calidad de Radio de Fases y el 'Indice de Calidad de Proceso.

El Yield mide la eficiencia de cada fase removiendo defectos. El Yield de una fase es el porcentaje de defectos de producto totales que son removidos en esa fase. El Yield de proceso es el porcentaje de defectos que son removidos antes de la primera compilaci'on. El Yield aumenta claramente cuando se comienzan a utilizar revisiones de dise'no y de c'odigo.

El COQ tiene tres componentes principales:

\begin{enumerate}
	\item \emph{Costo de las Fallas (CF)}. El costo total de las fases de compilaci'on y de pruebas;
	\item \emph{Costos de Evaluaci'on (CE)}. El tiempo utilizado en revisiones de c'odigo y de dise'no;
	\item \emph{Costos de Prevenci'on}. El costo de identificar causas de defectos y acciones para prevenirlos en el futuro.
\end{enumerate}

En la tabla \ref{MetricasCOQ} se muestran las m'etricas que se pueden obtener a partir del an'alisis del COQ\cite{Humphrey}.

\begin{table}[htbp]
	\centering
		\begin{tabular}{|l|l|l|} \hline
		\multicolumn{3}{|c|}{\textbf{F'ormulas COQ}} \\ \hline
		\multirow{4}{*}{\begin{math}CF = 100(\frac{TC + TT}{TTD})\end{math}} 
		& CF & Costo de Fallas \\
		& TC & Tiempo de Compilaci'on \\
		& TT & Tiempo de Pruebas \\
		& TTD & Tiempo Total de Desarrollo \\ \hline
		\multirow{4}{*}{\begin{math}CE = 100(\frac{TRD + TRP}{TTD})\end{math}} 
		& CE & Costo de Evaluaci'on \\
		& TRD & Tiempo de Revisi'on de Dise'no \\
		& TRP & Tiempo de Revisi'on de Compilaci'on \\
		& TTD & Tiempo Total de Desarrollo \\ \hline
		\multirow{2}{*}{\begin{math}TCOQ = CF + CE\end{math}} 
		& CE & Costo de Evaluaci'on \\
		& TTD & Tiempo Total de Desarrollo \\ \hline
		\multirow{2}{*}{\begin{math}CE\% = 100(\frac{CE}{TCOQ})\end{math}} 
		& CE & Costo de Evaluaci'on como \% del TTD\\
		& TTD & Tiempo Total de Desarrollo \\ \hline
		\multirow{3}{*}{\begin{math}RF = \frac{CE}{CF}\end{math}} 
		& RF & Raz'on de Falla \\
		& CE & Costo de Evaluaci'on \\
		& CF & Costo de Fallas \\ \hline		
		\end{tabular}
	\caption{M'etricas del COQ}
	\label{MetricasCOQ}
\end{table}

El Yield y el COQ son 'utiles, pero miden el trabajo que hiciste, no lo que est'as haciendo. La Tasa de Revisi'on y al Radio de Calidad por Fase proveen una manera de dar seguimiento y control a los tiempos de revisi'on. 

La tasa de revisi'on se utiliza principalmente para revisiones de c'odigo e inspecciones, y mide el n'umero de l'ineas de c'odigo (LOC) o p'aginas revisadas por hora.

El Radio de Calidad por Fase, Es el radio de tiempo utilizado en dos fases de proceso. El radio para la revisi'on es el tiempo utilizado para realizar revisiones dividido entre el tiempo de desarrollo.

El 'Indice de Calidad de Proceso (PQI), es una m'etrica compuesta por cinco sub-m'etricas, la cual nos permite analizar el desempe'no general de los procesos de una organizaci'on de software. El PQI se obtiene de multiplicar las cinco sub-m'etricas que se presentan en la tabla \ref{SubMetricasPQI} y el objetivo es que el resultado sea 1.0.

\begin{table}[htbp]
	\centering
		\begin{tabular}{|l|l|l|} \hline
		\multicolumn{3}{|c|}{\textbf{F'ormulas PQI}} \\ \hline
		\multirow{3}{*}{\begin{math}PQI-DP = \frac{TD}{TP}\end{math}} 
		& PQI-DP & PQI de Dise'no y Programaci'on \\
		& TD & Tiempo de Dise'no \\
		& TP & Tiempo Programaci'on \\ \hline
		\multirow{3}{*}{\begin{math}PQI-RD = 2(\frac{TRD}{TD})\end{math}} 
		& PQI-RD & PQI de Revisi'on de Dise'no \\
		& TRD & Tiempo de Revisi'on de Dise'no \\
		& TD & Tiempo de Dise'no \\ \hline
		\multirow{3}{*}{\begin{math}PQI-RP = 2(\frac{TRP}{TP})\end{math}} 
		& PQI-RP & PQI de Revisi'on de Programaci'on \\
		& TRP& Tiempo de Revisi'on de Programaci'on \\
		& TP & Tiempo de Programaci'on \\ \hline
		\multirow{3}{*}{\begin{math}PQI-DC = 20(10 + \frac{DC}{KLOC})\end{math}} 
		& PQI-DC & PQI para Defectos de Compilaci'on por KLOC\\
		& DC & Defectos de Compilaci'on \\
		& KLOC & Mil L'ineas de C'odigo \\ \hline
		\multirow{3}{*}{\begin{math}PQI-DT = \frac{10}{5 + \frac{DT}{KLOC}}\end{math}} 
		& PQI-DT & PQI para Defectos de Pruebas por KLOC \\
		& DT & Defectos de Pruebas \\
		& KLOC & Mil L'ineas de C'odigo \\ \hline		
		\end{tabular}
	\caption{Sub-M'etricas del PQI}
	\label{SubMetricasPQI}
\end{table}

\subsection{Administraci'on de la Calidad del Producto}
\noindent
El proceso de pruebas ha crecido hasta que ahora consume cerca de la mitad del calendario de desarrollo. La estrategia consiste en solucionar esto removiendo tantos defectos como sea posible antes de entrar en pruebas. Esta estrategia mejora tanto la calidad del producto como la productividad en el desarrollo.

En los sistemas de millones de LOC debemos enfocarnos en tener menos de diez errores por cada MLOC.

\subsection{Pr'acticas para la Mejora de Calidad del PSP}
\noindent

Existen seis principios que recomienda el PSP para la Mejora de la Calidad Personal\cite{Humphrey}:

\begin{enumerate}
	\item Para tener calendarios predecibles, se tiene que planear y dar seguimiento al trabajo personal;
	\item Para hacer planes precisos y que se les pueda dar seguimiento, estos planes tienen que ser detallados;
	\item Para hacer planes detallados, debes de basar los planes en datos hist'oricos;
	\item Para hacer un trabajo de alta calidad, debes de usar un proceso personal definido y medible;
	\item Ya que el trabajo de mala calidad no es predecible, la calidad es un pre requisito para la predictibilidad.
\end{enumerate}

\subsection{Prevenci'on de Defectos}
\noindent
Se debe de revisar los datos de los defectos que m'as se encuentran durante el desarrollo y las pruebas. Con esto se pueden establecer estrategias como enfocarse en los errores que:

\begin{itemize}
	\item Se encuentran en el programa final o en el periodo de pruebas;
	\item Aquellos que ocurren m'as frecuentemente;
	\item Aquellos que son m'as dif'iciles o costosos de corregir;
	\item Aquellos en los que se pueden realizar acciones preventivas sencillas;
	\item Aquellos que m'as nos molestan.
\end{itemize}

\subsection{T'ecnicas de Detecci'on de Defectos}
\noindent
Las t'ecnicas de detecci'on de defectos pueden ser definidas como la evaluaci'on y la revisi'on de un producto de trabajo por parte de uno o m'as compa'neros de trabajo calificados para realizar la actividad\cite{Owens1997}.

Existen diferentes tipos de t'ecnicas de detecci'on de defectos, unas m'as formales y r'igidas que otras. Evidentemente la diferencia radica en la forma de conducir la revisi'on del producto de trabajo. Tambi'en existen diferentes clasificaciones acerca de las t'ecnicas, pero creo que una clasificaci'on coherente consiste en separar las t'ecnicas que involucran a una sola persona y las t'ecnicas en las que participan dos o m'as miembros del equipo. Los tipos m'as utilizados son: Revisi'on Personal, Revisi'on entre Colegas, Caminatas, Inspecci'on

La revisi'on personal consiste en examinar el producto de trabajo antes de entregarlo a cualquier otro miembro del equipo, ya sea para su lectura, compilaci'on, revisi'on, implementaci'on o prueba.

Existen varias t'ecnicas de detecci'on de defectos que se realizan entre colegas y/o miembros de un equipo de desarrollo\cite{Harjumma2005}. Estas t'ecnicas se puede clasificar de acuerdo a su formalidad, de acuerdo con existen 6 diferentes tipos de t'ecnicas:

\begin{itemize}
	\item Revisi'on ad hoc;
	\item Revisi'on general;
	\item Revisi'on de parejas;
	\item Caminata;
	\item Revisi'on de equipo;
	\item Inspecci'on.
\end{itemize}

La caminata es un tipo de revisi'on en el que precisamente una persona (preparada especialmente para ello) pasa a trav'es del producto, exponi'endolo a una audiencia. Mediante esta t'ecnica se pueden obviar muchos detalles, con lo cual se reduce el tiempo de revisi'on. Sin embargo, esto puede ser contraproducente si el objetivo es precisamente detectar defectos que residen en los detalles. Al mismo tiempo, el proceso de revisi'on est'a definido por el producto de trabajo siendo revisado, a diferencia de la inspecci'on, en el que el proceso se determina por los puntos a revisar\cite{Freedman1984}.

La Inspecci'on es muy probablemente la t'ecnica m'as formal de detecci'on de defectos de software\cite{Harjumma2005}. Consiste de los siguientes pasos\cite{Owens1997}:

\begin{enumerate}
	\item \emph{Planeaci'on}: Seleccionar d'onde, cu'ando y qui'enes participar'an;
	\item \emph{Resumen}: Revisi'on general para que los revisores se familiaricen con el producto de trabajo;
	\item \emph{Preparaci'on}: Cada revisor lee el producto de trabajo e identifica posibles defectos. Todo esto generalmente mediante listas de chequeo. La persona que realiza el papel de l'ider, se prepara para la junta de revisi'on;
	\item \emph{Junta}: El l'ider modera la junta y realiza la revisi'on del producto. Los revisores lo interrumpen para discutir los defectos encontrados. Lo m'as importante es que NO se permite discutir posibles soluciones para ning'un defecto;
	\item \emph{Re-trabajo}: El autor del producto realiza las correcciones pertinentes;
	\item \emph{Seguimiento}: El autor del producto notifica al l'ider de las correcciones y 'estas son revisadas. 
\end{enumerate}

\subsection{?`Por qu'e Revisar los Programas?}
\noindent
Es la manera m'as r'apida y m'as barata para encontrar y corregir problemas antes de dise'nar una funci'on equivocada o implementar un dise'no incorrecto. Un poco de tiempo invertido revisando un programa puede ahorrar mucho tiempo durante las fases de compilaci'on y pruebas. A'un m'as importante, cuando todos en el equipo de desarrollo hacen revisiones de dise'no y de c'odigo a conciencia, el tiempo de integraci'on y de pruebas de sistema es reducido en un factor de cinco a diez.

\subsection{Principios de la Revisi'on}
Los principios de las revisiones personales son los siguientes\cite{Humphrey}:

\begin{itemize}
	\item Revisar personalmente todo el trabajo propio antes de pasar a la siguiente fase de desarrollo;
	\item Intentar lo mejor posible corregir todos los defectos antes de dar el producto de trabajo a otra persona en el equipo de desarrollo;
	\item Utilizar una lista de chequeo personal y seguir un proceso estructurado de revisi'on;
	\item Seguir las buenas pr'acticas de la revisi'on: revisar en incrementos peque'nos, hacer las revisiones en papel y hacerlas cuando est'as descansado;
	\item Medir el tiempo de la revisi'on, el tama'no de los productos revisados y el n'umero y tipo de defectos encontrados y perdidos;
	\item Usar los datos de las mediciones para mejorar el proceso personal de revisi'on;
	\item Dise'nas e implementar los productos para que sean f'aciles de revisar;
	\item Revisar los datos para identificar las formas de prevenir defectos.
\end{itemize}

\subsection{Lista de Chequeo de Revisi'on de C'odigo}
\noindent
Una lista de chequeo es una forma especializada que se usa en para hacer las revisiones. La lista de chequeo tambi'en te ayuda de disciplinar tu trabajo y te gu'ia en los pasos de revisi'on.

Se necesita que cada persona desarrolle su propia lista de chequeo, para que cada persona se enfoque en los errores que m'as comete, o en los que quiere evitar seg'un la estrategia que se siga, y que se completen todos los elementos de la lista. Para hacer un mejor uso de la lista de chequeo se tiene que dividir la lista en secciones con caracter'isticas similares para concentrarte en los mismos tipos de errores en cada pasada al c'odigo o al dise'no. Para elaborar una lista de chequeo se puede tomar como base la tabla \ref{DefectosPSP} \cite{Humphrey}.

\begin{table}[htbp]
	\centering
		\begin{tabular}{| l | l | l |}
			\hline
			\textbf{N'umero de Tipo} & \textbf{Nombre del Tipo} & \textbf{Descripci'on} \\ \hline
			10 & Documentaci'on & Comentarios y mensajes. \\ \hline
			20 & Sintaxis & Ortograf'ia, puntuaci'on y tipos. \\ \hline
			30 & Paquete & Administraci'on, librer'ias y versiones. \\ \hline
			40 & Asignaci'on & Declaraci'on, nombres duplicados y l'imites. \\ \hline
			50 & Interface & Procedimientos, referencias, I/O y formatos. \\ \hline
			60 & Chequeo & Mensajes de error y chequeos inadecuados. \\ \hline
			70 & Datos & Estructura y contenido. \\ \hline
			80 & Funci'on & L'ogica, apuntadores, ciclos, etc. \\ \hline
			90 & Sistema & Configuraci'on, tiempo y memoria. \\ \hline
			100 & Medio Ambiente & Dise'no, compilaci'on y pruebas.\\
			\hline
		\end{tabular}
	\caption{Clasificiaci'on de Defectos del PSP}
	\label{DefectosPSP}
\end{table}

La lista de chequeo es construida a partir de esta lista de defectos. Se deben proponer distintas actividades para enfocarse a remover los distintos tipos de defectos. La tabla \ref{ListaChequeoRevisionCodigoPSP} presenta un ejemplo de lista de chequeo\cite{Humphrey}:

\begin{table}[htbp]
	\centering
		\begin{tabular}{|l|l|} \hline
		\multicolumn{2}{|c|}{\textbf{Lista de Chequeo para la Revisi'on de C'odigo}} \\ \hline
		\textbf{Nombre del Revisor} &  \\ \hline
		\textbf{Nombre del Programa} &  \\ \hline
		\textbf{Lenguaje} &  \\ \hline
		\textbf{Prop'osito} & Ser una gu'ia para la revisi'on de c'odigo \\ \hline
		\multirow{3}{*}{\textbf{General}} 
		& - Revisa el programa por cada categoría. \\
		& - No intentar revisar dos categorías a la vez. \\
		& -	Cada que se complete un paso palomear el cuadro. \\ \hline
		\textbf{Documentaci'on} & - Los m'etodos est'an documentados correctamente. \\ \hline	
		\multirow{3}{*}{\textbf{Sintaxis}} 
		& - Todas las l'ineas del programa terminan en ";" .\\
		& - Todas las llaves, corchetes y par'entesis tienen su pareja. \\
		& -	El c'odigo est'a correctamente indentado. \\ \hline
		\multirow{2}{*}{\textbf{Paquete}} 
		& - El programa se encuentra en la carpeta correcta.\\
		& -	Todas las librerías requeridas est'an presentes. \\ \hline
		\multirow{4}{*}{\textbf{Asignaci'on}} 
		& - Las variables tienen el tipo de dato correcto.\\
		& - Las variables siguen las convenciones de nombrado.\\
		& - Todas las variables est'an inicializadas.\\
		& -	Las variables tienen el alcance adecuado.\\ \hline
		\multirow{3}{*}{\textbf{Interface}} 
		& - Los archivos le'idos o escritos existen.\\
		& -	Las llamadas a funciones son correctas. \\ \hline
		& - Las llamadas a funciones tienen los par'ametros adecuados. \\ \hline
		\multirow{2}{*}{\textbf{Chequeo}} 
		& - Los m'etodos utilizados manejan excepciones.\\
		& -	Los mensajes de error mandados son 'utiles. \\ \hline
		\multirow{2}{*}{\textbf{Datos}} 
		& - La base de datos utilizada existe.\\
		& -	Las consultas a la base de datos son correctas. \\ \hline
		\multirow{3}{*}{\textbf{Funci'on}} 
		& - La l'ogica de los m'etodos es correcta.\\
		& - Los apuntadores est'an definidos correctamente.\\
		& -	Los ciclos respetan el tama'no de los arreglos.\\ \hline
		\textbf{Sistema} & - El programa utiliza correctamente la memoria disponible.\\ \hline	
		\end{tabular}
	\caption{Lista de Chequeo para la Revisi'on de C'odigo de PSP}
	\label{ListaChequeoRevisionCodigoPSP}
\end{table}

La lista de chequeo aparte de ser personalizada, tiene que ser actualizada constantemente. La persona al seguir los procesos de calidad tiene una mejor'ia notable en la forma de hacer su trabajo, por lo tanto los errores que se comenten en el tiempo van cambiando y la lista tiene que ser actualizada. Tambi'en se tiene que tener en cuenta que las listas de chequeo cambian notablemente de un proyecto a otro, dependiendo del lenguaje de programaci'on que se utilice entre otros factores.

La intenci'on de la revisi'on de c'odigo es para asegurarte que todos los detalles son correctos. Una vez que hayas definido tus pr'acticas, debes de incorporarlas en tus est'andares y checarlos en tus revisiones.

La estrategia de la revisi'on es:

\begin{itemize}
	\item Para asegurarte que el c'odigo cubra todo el dise'no, revisa cada m'etodo para asegurarte que todas las funciones requeridas est'an incluidas;
	\item Para checar las librer'ias a incluir, examina cada m'etodo para asegurarte que existan las inclusiones necesarias para cada funci'on de la librer'ia;
	\item Para checar problemas de inicializaci'on, haz una caminata por la l'ogica de todos los m'etodos.
\end{itemize}

\subsection{Evaluando las Revisiones Personales}
\noindent
Algunas medidas 'utiles para evaluar las revisiones son:

\begin{itemize}
	\item El tama'no del programa revisado;
	\item El tiempo de revisi'on en minutos;
	\item N'umero de defectos encontrados;
	\item N'umero de defectos en el programa que se encontraron despu'es, en otras palabras aquellos que no fueron encontrados en la revisi'on.
\end{itemize}

Las m'etricas formales que se proponen por PSP son: Yield de Revisi'on, Densidad de Defectos, Tasa de Defectos y Tasa de Revisi'on. 

Yield de revisi'on es el porcentaje de defectos en el producto que fueron encontrados en la revisi'on. Un Yield alto es bueno, uno malo es pobre. La meta del Yield debe de ser el 100\%. La meta de PSP es encontrar y corregir todos los errores antes de la primera compilaci'on o las pruebas. Para hacer un estimado de Yield para cualquier fase, debes de asumir el Yield de la fase anterior.

La Tasa de Defectos es el n'umero de defectos que se encontraron en el c'odigo por LOC.

La Tasa de Revisi'on es el n'umero de l'ineas que se revisan por hora. El ideal es entre 200 y 400 l'ineas por hora.

La efectividad de los m'etodos de revisi'on es el radio de defectos removidos por hora en la revisi'on.

\subsection{Efectividad de la Revisi'on}
\noindent
Las revisiones de c'odigos son inherentemente mejores que las pruebas\cite{Humphrey}. Depuraci'on es el proceso de encontrar c'odigo defectuoso que causa que el programa se comporte impropiamente. La cantidad de tiempo que se gasta realizando el debugging generalmente tiene poca relaci'on con la complejidad del defecto\cite{Humphrey}.

La meta de la revisi'on es remover el m'aximo n'umero de defectos, en otras palabras llegar a pruebas con cero defectos.

En una revisi'on, personalmente revisas tu propio programa. Una inspecci'on es una revisi'on en equipo de un programa. Despu'es de las revisiones personales, la inspecci'on es la t'ecnica m'as valiosa que un equipo de desarrollo de software puede utilizar.

\section{Dise'no de Software}
\noindent
La principal herramienta a disposici'on de los ingenieros de software son las abstracciones. Podemos crear abstracciones arbitrariamente y combinarlas en abstracciones m'as grandes. Si cumplimos con las capacidades de los sistemas que soportamos podemos tambi'en crear las estructuras l'ogicas que necesitemos.

El principal problema reside en la escala o el tama'no de los sistemas de software. La forma de subdividir los sistemas tiene que ser coherente y realmente ayudar a resolver los problemas de complejidad. Ya que si en el caso de un sistema de 1000000 LOC, creas 500 tipos de 10 LOC, entonces tendr'ias que dise'nar un sistema de 100000 LOC, lo que parece una ayuda, pero en realidad est'as forzando a los dise'nadores a relacionar coherentemente los 500 tipos distintos. Para que la escalabilidad sea 'util, no solamente se debe de capturar los requerimientos f'isicos de la escalabilidad, si no capturar un nivel de funcionalidad significativa en las partes.

La forma m'as cl'asica es utilizar la regla de divide-y-vencer'as. En otras palabras, el sistema se tiene que dividir en partes m'as peque'nas, las cuales deben de ser vistas como subsistemas coherentes o componentes. Si esto se hace correctamente, se reduce la complejidad en un factor de diez o m'as.  Sin embargo hacer esto correctamente es una tarea dif'icil, a la que se llama dise'no. El dise'no de calidad tiene dos partes: la calidad del concepto de dise'no y la calidad de la representaci'on del dise'no.

\subsection{?`Por qu'e Dise'nar?}
\noindent
Producir un dise'no claro, completo y libre de defectos hace m'as lento el proceso individual de desarrollo, sin embargo, si todo el equipo de desarrollo hace lo mismo, acelerar'a el trabajo en equipo ya que facilitar'a el trabajo de integraci'on y pruebas de sistema.

\subsection{El Proceso de Dise'no}
\noindent
El dise'no de software es una actividad creativa la cual no puede ser reducida a un proceso rutinario. Sin embargo, esta actividad, no tiene que carecer por completo de estructura. El dise'no generalmente inicia revisando el prop'osito del producto, obteniendo datos relevantes, produciendo una vista general del dise'no y llenando los detalles. Para dise'nos complejos, los buenos dise'nadores siguen un proceso din'amico. Ellos trabajan en un nivel conceptual por un periodo de tiempo y despu'es ahondan en cada parte.

El principio de incertidumbre de los requerimientos: Los requerimientos nunca van a ser completamente conocidos hasta que los usuarios utilicen el producto terminado. Tomando en cuenta este principio, el trabajo del dise'nador es crear una soluci'on funcional a un problema mal definido.

Ocasionalmente, el dise'nador no va a ser capaz de especificar una funci'on hasta que se haya dise'nado, construido y probado. En estos casos se deben de construir prototipos para estas funciones. Antes de desarrollar un prototipo, se debe de especificar su prop'osito y las preguntas que va a responder.

\subsection{Niveles de Diseño}
\noindent
Los diferentes niveles de dise'no son\cite{Humphrey}:

\begin{enumerate}
	\item \emph{El dise'no conceptual}. Es un concepto de planeaci'on que se utiliza para estimar el tama'no del producto.
	\item \emph{Dise'no a nivel de sistema (SLD)}. Es la vista general del sistema completo de hardware y software. Si se est'a trabajando en frenos para autos, el nivel de sistema ser'ia el auto, pero en cambio s'i se trabaja con pistones, el nivel de sistema ser'ia el motor.
	\item \emph{Dise'no de alto nivel (HLD)}. Este dise'no tiene como objetivo dividir el sistema que se est'a desarrollando en partes m'as peque'nas o componentes.
	\item \emph{Dise'no detallado (DLD)}. Este nivel de dise'no toma los componentes especificados por el HLD y define como construirlos.
	\item \emph{Dise'no de implementaci'on (ILD)}. Toma el producto del DLD y lo refina de una forma en que el producto puede ser autom'aticamente construido.
\end{enumerate}

\subsection{Requerimientos y Dise'no}
\indent
Se puede argumentar que se necesita tener el conjunto completo de requerimientos antes de comenzar con el trabajo, pero esto es raramente posible debido a las siguientes razones\cite{Humphrey}:

\begin{itemize}
	\item La especificaci'on de requerimientos es una habilidad especializada;
	\item Los requerimientos cambian conforme el proceso de desarrollo avanza;
	\item La soluci'on que se desarrolla probablemente cambie el problema;
	\item El principio de incertidumbre de los requerimientos.
\end{itemize}

Los requerimientos deben de ser los m'as claro posible. Una vez que se tiene la definici'on completa se debe de comenzar con el dise'no.

\subsection{Estrategias de Dise'no y Desarrollo}
\indent
Cuando se est'a siguiendo una estrategia de desarrollo se deben de seguir las siguientes directrices\cite{Humphrey}:

\begin{enumerate}
	\item Cuando sea pr'actico, completar primero el HLD;
	\item El dise'no de un programa no se considera completo hasta que las especificaciones de todas sus abstracciones est'an completas;
	\item Registre los supuestos para despu'es asegurarte que son v'alidos;
	\item Escriba notas acerca del dise'no que expliquen la l'ogica en las decisiones de dise'no;
	\item Trate de resolver todas las incertidumbres antes de comenzar con el dise'no;
	\item Penetre en tantos niveles de dise'no como sea necesario para resolver las incertidumbres.
\end{enumerate}

Algunas estrategias de desarrollo son las siguientes\cite{Humphrey}:

\begin{itemize}
	\item \emph{La estrategia progresiva}. Es una manera natural de desarrollar un sistema que consiste de funciones secuenciales. Si existe una estructura central, se puede dividir en pedazos verticales, implementando cada pedazo en un ciclo completo de desarrollo. Esta estrategia tiene la ventaja de ser f'acil de definir e implementar. Tiene la desventaja de que no se puede probar exhaustivamente el comportamiento de cada pedazo.
	\item \emph{La estrategia de mejoras funcionales}. Define una versi'on inicial del sistema y le agrega mejoras. Esta estrategia se sigue com'unmente en la actualizaci'on de grandes sistemas. En esta estrategia se construye un sistema funcional tan pronto como sea posible. Provee una base temprana para las pruebas de seguridad y desempe'no. El principal problema de esta estrategia es que el primer paso puede ser muy grande.
	\item \emph{La estrategia camino-r'apido}. Es parecida a la estrategia de mejoras funcionales, con la diferencia de que la versi'on inicial del sistema est'a dise'nada para demostrar el desempe'no. Ya que se enfoca en el desempe'no, la versi'on inicial del sistema solo debe de contener la l'ogica m'inima para controlar las funciones sensitivas al desempe'no. La ventaja principal es que expone problemas de tiempo en una etapa temprana. Para sistemas que tienen restricciones de tiempo o para versiones iniciales de un sistema operativo puede ser una estrategia muy atractiva. La principal desventaja es tambi'en el paso inicial.
	\item \emph{La estrategia boba}. Sigue un enfoque de arriba hacia abajo. Inicia con las funciones de alto nivel del sistema y obvia el resto de las funciones con regresos predefinidos. Una vez que las funciones de alto nivel son probadas, implementa gradualmente las funciones obviadas. Esta estrategia tiene la ventaja de construir el sistema en pazos peque'nos y provee considerable flexibilidad al momento de ordenar la implementaci'on funcional. La principal desventaja de esta estrategia es que mucha de la funcionalidad 'util no es vista hasta fases avanzadas del proceso de desarrollo.
\end{itemize}

\subsection{Calidad en el Dise'no}
\indent
Los factores que afectan la calidad en el dise'no son la precisi'on y la completez\cite{Humphrey}. El dise'no de software debe de contener una soluci'on completa y precisa al problema.

Se necesita un dise'no precisamente documentado, ya que si no al momento de implementaci'on se tendr'a que completar el dise'no lo que es altamente propenso a errores.

Se puede desperdiciar tiempo sobre especificando el dise'no, pero un dise'no que no est'e suficientemente especificado puede ser costoso y ser propenso a errores. Para ser m'as eficiente, se necesita definir espec'ificamente el contenido que tendr'a el dise'no. Esto te ayudar'a a producir un dise'no de alta calidad y te guiar'a al momento de hacer revisiones. Siempre y cuando cumplas con los criterios de salida, puedes utilizar los m'etodos de dise'no que prefieras.

Las personas que utilizar'an el dise'no son: Programadores, dise'nadores, documentadores y el equipo de pruebas. A continuaci'on se describe:

\begin{itemize}
	\item Administraci'on de sistema: Registro de seguimiento de problemas, restricciones de implementaci'on, descripci'on de la funci'on del sistema, notas de aplicaci'on, escenarios de uso y restricciones del sistema;
	\item Ingenieros de sistema: Una descripci'on de los datos y archivos relevantes, una descripci'on de los mensajes de sistema, condiciones especiales y razones por las que se tomaron decisiones en el dise'no del sistema;
	\item Dise'nadores de software: Una imagen de en qu'e parte del sistema encaja el programa, una imagen l'ogica del programa, una lista de las clases (clases, componentes o partes) relacionadas, una lista de las variables externas, una descripci'on precisa de todas las referencias y la descripci'on de la l'ogica del programa (pseudoc'odigo).
\end{itemize}

\subsection{Plantillas de Dise'no}
\noindent
La falta de un dise'no preciso es la fuente de muchos errores de implementaci'on. Para lograr una representaci'on adecuada del sistema requieren 3 cosas: Producir un dise'no coherente, registrar toda la informaci'on de dise'no y  registrar esa informaci'on en una forma precisa y entendible.

Una vez generado el dise'no se debe analizar su correcci'on, completez y consistencia, para asegurarse que la notaci'on l'ogica sea precisa. La notaci'on usada para el dise'no debe ser concisa y precisa, y debe de cumplir con las siguientes caracter'isticas\cite{Humphrey}:

\begin{itemize}
	\item Debe ser capaz de representar el dise'no precisa y completamente;
	\item Debe ser entendida y usada por las personas que usan el dise'no;
	\item Debe ayudar a verificar que el dise'no hace lo que se pretende.
\end{itemize}

Un buen dise'no debe tener m'inima redundancia. En las plantillas de PSP, cada 'item solo se registra una vez, y se usan referencias cuando es necesario. Existen 4 categor'ias para agrupar los elementos de dise'no en una plantilla de PSP\cite{Humphrey}:

\begin{enumerate}
	\item \emph{Externo-est'atico}: Define las relaciones est'aticas de una parte con otras partes o con elementos del sistema;
	\item \emph{Externo-din'amico}: Define interacciones  de una parte con otras partes o elementos del sistema;
	\item \emph{Interno-est'atico}: Contiene una descripci'on est'atica de un m'odulo o parte, como su estructura l'ogica detallada;
	\item \emph{Interno-din'amico}: Define las caracter'isticas din'amicas de las partes.
\end{enumerate}

Existen 4 plantillas de dise'no diferentes en el PSP\cite{Humphrey}:

\begin{itemize}
	\item \emph{Plantilla de Especificaci'on Operacional (OST)}. El OST es una forma simplificada de casos de uso que es utilizada para describir el comportamiento operacional de un programa. Ayuda a visualizar c'omo el programa debe reaccionar en varios escenarios de uso. Cuando una decisi'on de dise'no involucra a un actor, se produce un escenario para registrar c'omo el actor percibe la acci'on. En comparaci'on con el UML (Unified Modeling Language) es una combinaci'on de diagramas de casos de uso, descripci'on de casos de uso, diagramas de actividades y diagramas de secuencia;
	\item \emph{Plantilla de Especificaci'on Funcional (FST)}. El FST provee una forma simple de documentar la mayor'ia de los contenidos de un diagrama de clases de UML. Este tipo de plantilla describe las partes, incluyendo sus m'etodos, relaciones y limitantes (restricciones). Las partes pueden ser clases, m'odulos  o incluso un sistema entero. El FST provee una descripci'on detallada de cada una de esas partes. En comparaci'on con el UML es un diagrama de clases;
	\item \emph{Plantilla de Especificaci'on de Estados (SST)}. Esta plantilla provee una forma simple y precisa de especificar el comportamiento de los estados de un sistema, el cual es determinado por sus entradas y el estado actual. Programas con m'ultiples estados son denominados m'aquinas de estados. En comparaci'on con el UML es un diagrama de estados;
	\item \emph{Plantilla de Especificaci'on L'ogica (LST)}. Es un tipo de plantilla que usa un lenguaje simple de dise'no de programaci'on (PDL) para describir la l'ogica del programa. Los PDLs tambi'en son conocidos como pseudoc'odigo. La plantilla contiene una descripci'on en pseudoc'odigo de un programa. El objetivo es describir de manera clara y concisa qu'e har'a el programa y c'omo. Se debe usar lenguaje humano ordinario, evitando usar expresiones de programaci'on. De otra manera se estar'ia programando el c'odigo del programa, y no el dise'no.
\end{itemize}

Las plantillas tambi'en son 'utiles al mejorar programas ya existentes. Ya que para producir mejoras sin defectos es necesario conocer el dise'no, o es posible que haya errores de dise'no, las plantillas ayudan a documentar el dise'no de estos programas.

Estas plantillas se pueden usar de manera escalada. Es decir, en un sistema muy grande, se pueden usar plantillas de FST y OST para definir la funcionalidad del sistema en general, y usar plantillas separadas para definir la funcionalidad de los sub-sistemas o componentes.

\subsection{Verificaci'on de Dise'no}
\noindent
Para programas largos y complejos, hasta los m'etodos de verificaci'on de dise'no que m'as consumen tiempo y m'as trabajo requieren son m'as efectivos y r'apidos que las pruebas. Los siguientes m'etodos de verificaci'on son relativamente r'apidos de aprender:

\begin{itemize}
	\item Est'andares de dise'no;
	\item Verificaci'on por tabla de ejecuci'on;
	\item Verificaci'on por tabla de seguimiento;
	\item Verificaci'on de m'aquinas de estado;
	\item Verificaci'on anal'itica.
\end{itemize}

Los programas tienen que ser verificados porque los desarrolladores tienen la creencia que pocos defectos en un programa son aceptables mientras el programa se ejecute normalmente bien\cite{Humphrey}. Pero qu'e pasa cuando 1 o 2 defectos por cada 100 l'ineas de c'odigo se convierten en 10,000 a 20,000 en 1,000,000 de l'ineas de c'odigo.

Es recomendable utilizar t'ecnicas de verificaci'on de dise'no para reducir el n'umero de defectos y aumentar la calidad del programa. El problema no es que las pruebas sean malas, sino que no son suficientes. Imagina analizar todas las posibilidades de ejecuci'on de cierto programa, eso nos llevar'ia demasiados a'nos. Por eso es importante utilizar t'ecnicas de verificaci'on para reducir el n'umero de defectos, que adem'as se traduce en la reducci'on del costo para encontrar esos defectos, ya que se encuentran en una etapa temprana de desarrollo.

Aunque no es una t'ecnica de verificaci'on en s'i, es importante para comparar el dise'no de un programa contra las bases de los est'andares. Todos los est'andares definen convenciones para el producto, est'andares de dise'no del producto y est'andares para reutilizaci'on de c'odigo.

Las convenciones para el producto final incluyen las interfaces de usuario, la manera de atacar errores, convenciones de nombres, procedimientos de instalaci'on y la ayuda. El est'andar de dise'no del producto abarca desde las convenciones hasta la arquitectura del sistema. Los est'andares para reutilizaci'on de c'odigo precisan que las partes a reutilizar est'en completamente definidas, sean de la mayor calidad y est'en soportadas adecuadamente.

Las distintas t'ecnicas de verificaci'on son\cite{Humphrey}:

\begin{itemize}
	\item \emph{Verificaci'on por Tabla de Ejecuci'on}. El prop'osito de esta t'ecnica es verificar el flujo l'ogico de ejecuci'on del programa. Esta t'ecnica puede consumir bastante tiempo, sin embargo, es bastante confiable, sencilla y es mucho m'as r'apida para identificar problemas complejos de dise'no que las pruebas. Es importante seguir un proceso para realizar esta verificaci'on, para de esta manera maximizar su efectividad sin tener que desarrollar demasiados casos o escenarios. Se recomienda comenzar identificando los ciclos y rutinas complejas para su revisi'on. Posteriormente definir c'omo se har'a el an'alisis. Si de abajo hacia arriba o de arriba hacia abajo, esto depende de cu'al de los niveles (alto o bajo) sea el m'as s'olido en el dise'no. Si el nivel alto se ve s'olido, se recomienda comenzar con el nivel bajo y viceversa.
	\item \emph{Verificaci'on por Tabla de Seguimiento}. Es muy similar a la tabla de ejecuci'on, solamente que aqu'i se realiza la verificaci'on de una manera m'as general. Con la tabla de ejecuci'on, b'asicamente se emula el funcionamiento de una computadora. Con la tabla de seguimiento, primero se consideran todos los posibles casos l'ogicos y se selecciona un escenario para cada caso. Aunque son muy similares, en general las tablas de seguimiento son mucho m'as eficientes que las tablas de ejecuci'on. El m'etodo para ejecutar esta t'ecnica de verificaci'on es el mismo que para las tablas de ejecuci'on. Durante el an'alisis mediante esta t'ecnica, es bueno considerar la robustez del programa. Como por ejemplo, cu'ales ser'ian los l'imites de ejecuci'on y si el dise'no los soportar'a, cu'ales son las excepciones que se pueden presentar y si el dise'no las manejar'a correctamente. Es importante considerar que si la l'ogica del dise'no es demasiado compleja para ser analizada por una tabla de seguimiento, lo mejor ser'ia redise'nar esta parte.
	\item \emph{Verificaci'on de M'aquinas de Estado}. Si el programa incluye m'aquinas de estado, es importante verificar que estas m'aquinas hayan sido dise'nadas correctamente. De manera general, se considera que una m'aquina de estado es correcta si se puede alcanzar el estado de retorno (si es que lo hay) desde cualquier otro estado y si las transiciones entre los estados son completas y ortogonales.
	\item \emph{Una funci'on completa es aquella que incluye todas las condiciones l'ogicas posibles}. Existen t'ecnicas, como los mapas de Karnaugh, para determinar si una funci'on es completa o  no. Adem'as, un conjunto de funciones es ortogonal si ninguno de sus miembros tiene ninguna condici'on en com'un. Si una m'aquina de estado cumple con estas dos condiciones, se puede decir que es una m'aquina de estado correctamente dise'nada.
	\item \emph{Verificaci'on Anal'itica}. Dentro de las verificaciones anal'iticas existe un caso especial que es la verificaci'on de ciclos. La verificaci'on de ciclos nos ayuda a asegurarnos que el programa no caer'a en ning'un ciclo infinito, no se quedar'a atorado y no presentar'a ning'un comportamiento extra'no. En general, la verificaci'on de ciclos consiste en verificar que las precondiciones del ciclo se cumplan siempre, que se garantice la terminaci'on del ciclo para cualquier argumento que afecte al ciclo y que se mantenga la identidad cuando se cumple la condici'on de terminaci'on, es decir, que no se ejecute una o m'as veces de m'as.
\end{itemize}

As'i mismo, existen otras t'ecnicas de verificaci'on anal'iticas que ayudan a verificar la l'ogica del programa. Para seleccionar alguna t'ecnica en particular o alguna herramienta que realice esta t'ecnica, es importante considerar lo siguiente:

\begin{itemize}
	\item Si la t'ecnica puede conducir a resultados err'oneos;
	\item Si la t'ecnica podr'a encontrar todos los defectos de una categor'ia en especial o solamente algunos;
	\item La profundidad con la que podr'a realizar el an'alisis;
	\item La eficiencia respecto al tiempo que tomar'a el an'alisis;
	\item Si se necesita que el producto est'e finalizado completamente o no.
\end{itemize}

El tipo de productos que puede verificar. Si es de prop'osito general o de alg'un dominio en espec'ifico.

Las herramientas que proveen una verificaci'on autom'atica puede ser muy 'utiles, pero tambi'en peligrosas si no se usan adecuadamente. Siempre es necesario tener en cuenta que es muy poco probable que estas herramientas muestren el 100\% de errores cometidos en el dise'no. Por lo que se recomienda realizar siempre revisiones personales al dise'no y otras t'ecnicas de verificaci'on antes de utilizar herramientas para realizar una verificaci'on automatizada.

Cuando se dise'nan programas complejos, siempre se cometen errores. Por lo tanto, siempre ser'a importante realizar revisiones completas a todos los dise'nos que se hagan. Adem'as, es importante contar con una estrategia de verificaci'on que permita maximizar los resultados de la verificaci'on. Esta estrategia puede no ser la misma para diferentes tipos de programas. 

Sin embargo, el mejor momento para realizar la verificaci'on y los an'alisis siempre ser'a mientras se produce el dise'no. Mantener el registro de resultados actualizado y seguir procedimientos para la revisi'on del dise'no ser'an dos tareas que maximizar'an los resultados de la verificaci'on.

\section{Seguimiento de Defectos}
\noindent

\section{Costo de la Calidad en el Desarrollo de Software}
\noindent

\clearpage